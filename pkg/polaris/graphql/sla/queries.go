// Code generated by queries_gen.go DO NOT EDIT.

// MIT License
//
// Copyright (c) 2021 Rubrik
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package sla

// assignSla GraphQL query
var assignSlaQuery = `mutation SdkGolangAssignSla(
    $slaOptionalId:                   UUID,
    $slaDomainAssignType:             SlaAssignTypeEnum!,
    $objectIds:                       [UUID!]!,
    $applicableWorkloadType:          WorkloadLevelHierarchy,
    $existingSnapshotRetention:       GlobalExistingSnapshotRetention,
    $shouldApplyToExistingSnapshots:  Boolean,
    $shouldApplyToNonPolicySnapshots: Boolean,
) {
    result: assignSla(input: {
        slaOptionalId:                   $slaOptionalId,
        slaDomainAssignType:             $slaDomainAssignType,
        objectIds:                       $objectIds,
        applicableWorkloadType:          $applicableWorkloadType
        existingSnapshotRetention:       $existingSnapshotRetention,
        shouldApplyToExistingSnapshots:  $shouldApplyToExistingSnapshots,
        shouldApplyToNonPolicySnapshots: $shouldApplyToNonPolicySnapshots,
    }) {
        success
    }
}`

// cloudNativeTagRules GraphQL query
var cloudNativeTagRulesQuery = `query SdkGolangCloudNativeTagRules($objectType: CloudNativeTagObjectType!, $filters: [CloudNativeFilter!]) {
    result: cloudNativeTagRules(sortBy: NAME, sortOrder: ASC, objectType: $objectType, filters: $filters) {
        tagRules {
            id
            name
            objectType
            tag {
                matchAllValues
                tagKey
                tagValue
            }
            applyToAllCloudAccounts
            cloudNativeAccounts {
                id
                name
            }
            effectiveSla {
                id
                name
            }
        }
    }
}`

// createCloudNativeTagRule GraphQL query
var createCloudNativeTagRuleQuery = `mutation SdkGolangCreateCloudNativeTagRule(
    $tagRuleName:             String!,
    $objectType:              CloudNativeTagObjectType!,
    $tag:                     TagType!,
    $cloudNativeAccountIds:   CloudNativeIds,
    $applyToAllCloudAccounts: Boolean
) {
    result: createCloudNativeTagRule(input: {
        tagRuleName:             $tagRuleName,
        objectType:              $objectType,
        tag:                     $tag,
        cloudNativeAccountIds:   $cloudNativeAccountIds,
        applyToAllCloudAccounts: $applyToAllCloudAccounts
    }) {
        tagRuleId
    }
}`

// createGlobalSla GraphQL query
var createGlobalSlaQuery = `mutation SdkGolangCreateGlobalSla(
    $archivalSpecs:              [ArchivalSpecInput!],
    $backupLocationSpecs:        [BackupLocationSpecInput!],
    $backupWindows:              [BackupWindowInput!],
    $description:                String,
    $firstFullBackupWindows:     [BackupWindowInput!],
    $isRetentionLockedSla:       Boolean,
    $localRetentionLimit:        SlaDurationInput,
    $name:                       String!,
    $objectSpecificConfigsInput: ObjectSpecificConfigsInput,
    $objectTypes:                [SlaObjectType!]!,
    $replicationSpecsV2:         [ReplicationSpecV2Input!],
    $retentionLockMode:          RetentionLockMode,
    $snapshotSchedule:           GlobalSnapshotScheduleInput!
) {
    result: createGlobalSla(input: {
        archivalSpecs:              $archivalSpecs,
        backupLocationSpecs:        $backupLocationSpecs,
        backupWindows:              $backupWindows,
        description:                $description,
        firstFullBackupWindows:     $firstFullBackupWindows,
        isRetentionLockedSla:       $isRetentionLockedSla,
        localRetentionLimit:        $localRetentionLimit,
        name:                       $name,
        objectSpecificConfigsInput: $objectSpecificConfigsInput,
        objectTypes:                $objectTypes,
        replicationSpecsV2:         $replicationSpecsV2,
        retentionLockMode:          $retentionLockMode,
        snapshotSchedule:           $snapshotSchedule
    }) {
        id
    }
}`

// deleteCloudNativeTagRule GraphQL query
var deleteCloudNativeTagRuleQuery = `mutation SdkGolangDeleteCloudNativeTagRule($ruleId: UUID!) {
    result: deleteCloudNativeTagRule(input: {
        ruleId: $ruleId
    })
}`

// deleteGlobalSla GraphQL query
var deleteGlobalSlaQuery = `mutation SdkGolangDeleteGlobalSla($id: UUID!) {
    result: deleteGlobalSla(id: $id) {
        success
    }
}`

// slaDomains GraphQL query
var slaDomainsQuery = `query SdkGolangSlaDomains($after: String, $filter: [GlobalSlaFilterInput!]) {
    result: slaDomains(sortBy: NAME, sortOrder: ASC, after: $after,  filter: $filter) {
        nodes {
            ... on GlobalSlaReply {
                archivalSpecs {
                    frequencies
                    threshold
                    thresholdUnit
                    storageSetting {
                        id
                        name
                    }
                }
                backupLocationSpecs {
                    archivalGroup {
                        id
                    }
                }
                backupWindows {
                    durationInHours
                    startTimeAttributes {
                        dayOfWeek {
                            day
                        }
                        hour
                        minute
                    }
                }
                description
                firstFullBackupWindows {
                    durationInHours
                    startTimeAttributes {
                        dayOfWeek {
                            day
                        }
                        hour
                        minute
                    }
                }
                id
                isRetentionLockedSla
                localRetentionLimit {
                    duration
                    unit
                }
                name
                objectSpecificConfigs {
                    awsNativeS3SlaConfig {
                        archivalLocationId
                        archivalLocationName
                        continuousBackupRetentionInDays
                    }
                    awsRdsConfig {
                        logRetention {
                            duration
                            unit
                        }
                    }
                    azureBlobConfig {
                        backupLocationId
                        backupLocationName
                        continuousBackupRetentionInDays
                    }
                    azureSqlDatabaseDbConfig {
                        logRetentionInDays
                    }
                    azureSqlManagedInstanceDbConfig {
                        logRetentionInDays
                    }
                }
                objectTypes
                retentionLockMode
                replicationSpecsV2 {
                    awsRegion
                    awsTarget {
                      accountId
                      region
                    }
                    azureRegion
                    azureTarget {
                      subscriptionId
                      region
                    }
                    retentionDuration {
                      duration
                      unit
                    }
                }
                snapshotSchedule {
                    minute {
                        basicSchedule {
                            frequency
                            retention
                            retentionUnit
                        }
                    }
                    hourly {
                        basicSchedule {
                            frequency
                            retention
                            retentionUnit
                        }
                    }
                    daily {
                        basicSchedule {
                            frequency
                            retention
                            retentionUnit
                        }
                    }
                    weekly {
                        basicSchedule {
                            frequency
                            retention
                            retentionUnit
                        }
                        dayOfWeek
                    }
                    monthly {
                        basicSchedule {
                            frequency
                            retention
                            retentionUnit
                        }
                        dayOfMonth
                    }
                    quarterly {
                        basicSchedule {
                            frequency
                            retention
                            retentionUnit
                        }
                        dayOfQuarter
                        quarterStartMonth
                    }
                    yearly {
                        basicSchedule {
                            frequency
                            retention
                            retentionUnit
                        }
                        dayOfYear
                        yearStartMonth
                    }
                }
                version
            }
        }
        pageInfo {
            endCursor
            hasNextPage
        }
    }
}`

// slaProtectedObjects GraphQL query
var slaProtectedObjectsQuery = `query SdkGolangSlaProtectedObjects($slaIds: [UUID!]!, $after: String, $filter: GetProtectedObjectsFilterInput) {
    result: slaProtectedObjects(
        slaIds: $slaIds
        after:  $after
        filter: $filter
    ) {
        nodes {
            id
            name
            objectType
            effectiveSla
            protectionStatus
        }
        pageInfo {
            endCursor
            hasNextPage
        }
    }
}`

// updateCloudNativeTagRule GraphQL query
var updateCloudNativeTagRuleQuery = `mutation SdkGolangUpdateCloudNativeTagRule(
    $tagRuleId:               UUID!,
    $tagRuleName:             String!,
    $cloudNativeAccountIds:   CloudNativeIds,
    $applyToAllCloudAccounts: Boolean
) {
    result: updateCloudNativeTagRule(input: {
        tagRuleId:               $tagRuleId,
        tagRuleName:             $tagRuleName,
        cloudNativeAccountIds:   $cloudNativeAccountIds,
        applyToAllCloudAccounts: $applyToAllCloudAccounts
    })
}`

// updateGlobalSla GraphQL query
var updateGlobalSlaQuery = `mutation SdkGolangUpdateGlobalSla(
    $archivalSpecs:                   [ArchivalSpecInput!],
    $backupLocationSpecs:             [BackupLocationSpecInput!],
    $backupWindows:                   [BackupWindowInput!],
    $description:                     String,
    $firstFullBackupWindows:          [BackupWindowInput!],
    $id:                              String!,
    $isRetentionLockedSla:            Boolean,
    $localRetentionLimit:             SlaDurationInput,
    $name:                            String!,
    $objectSpecificConfigsInput:      ObjectSpecificConfigsInput,
    $objectTypes:                     [SlaObjectType!]!,
    $replicationSpecsV2:              [ReplicationSpecV2Input!],
    $retentionLockMode:               RetentionLockMode,
    $shouldApplyToExistingSnapshots:  ShouldApplyToExistingSnapshots,
    $shouldApplyToNonPolicySnapshots: ShouldApplyToNonPolicySnapshots,
    $snapshotSchedule:                GlobalSnapshotScheduleInput!
) {
    result: updateGlobalSla(input: {
        archivalSpecs:                   $archivalSpecs,
        backupLocationSpecs:             $backupLocationSpecs,
        backupWindows:                   $backupWindows,
        description:                     $description,
        firstFullBackupWindows:          $firstFullBackupWindows,
        id:                              $id
        isRetentionLockedSla:            $isRetentionLockedSla,
        localRetentionLimit:             $localRetentionLimit,
        name:                            $name,
        objectSpecificConfigsInput:      $objectSpecificConfigsInput,
        objectTypes:                     $objectTypes,
        replicationSpecsV2:              $replicationSpecsV2,
        retentionLockMode:               $retentionLockMode,
        shouldApplyToExistingSnapshots:  $shouldApplyToExistingSnapshots
        shouldApplyToNonPolicySnapshots: $shouldApplyToNonPolicySnapshots
        snapshotSchedule:                $snapshotSchedule
    }) {
        id
    }
}`
