// Code generated by queries_gen.go DO NOT EDIT.

// MIT License
//
// Copyright (c) 2021 Rubrik
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

package cluster

// allClusterGlobalSlas GraphQL query
var allClusterGlobalSlasQuery = `query SdkGolangAllClusterGlobalSlas($clusterUuid: UUID!) {
  result: allClusterGlobalSlas(cdmClusterUUID: $clusterUuid) {
    id
    name
  }
}`

// canIgnoreClusterRemovalPrechecks GraphQL query
var canIgnoreClusterRemovalPrechecksQuery = `query SdkGolangCanIgnoreClusterRemovalPrechecks($clusterUuid: UUID!) {
  result: canIgnoreClusterRemovalPrechecks(clusterUuid: $clusterUuid) {
    isDisconnected
    ignorePrecheckTime
    lastConnectionTime
    canIgnorePrecheck
    isAirGapped
  }
}`

// clusterDnsServers GraphQL query
var clusterDnsServersQuery = `query SdkGolangClusterDnsServers($clusterUuid: UUID!) {
  result: clusterDns(clusterUuid: $clusterUuid) {
    servers
    domains
  }
}`

// clusterNtpServers GraphQL query
var clusterNtpServersQuery = `query SdkGolangClusterNtpServers($id: String!) {
  result: clusterNtpServers(input: { id: $id }) {
    data {
      server
      symmetricKey {
        key
        keyId
        keyType
      }
    }
  }
}`

// clusterRcvLocations GraphQL query
var clusterRcvLocationsQuery = `query SdkGolangClusterRcvLocations(
  $clusterUuid: UUID!
  $first: Int
  $after: String
  $last: Int
  $before: String
  $sortOrder: SortOrder
) {
  result: clusterRcvLocations(
    cdmClusterUUID: $clusterUuid
    first: $first
    after: $after
    last: $last
    before: $before
    sortOrder: $sortOrder
  ) {
    edges {
      cursor
      node {
        id
        name
      }
    }
  }
}`

// clusterSettings GraphQL query
var clusterSettingsQuery = `query SdkGolangClusterSettings($id: UUID!) {
  result: cluster(clusterUuid: $id) {
    id
    name
    version
    status
    status
    timezone
    geoLocation {
      address
    }
    ipmiInfo {
      isAvailable
      usesHttps
      usesIkvm
    }
  }
}`

// removeCdmCluster GraphQL query
var removeCdmClusterQuery = `mutation SdkGolangRemoveCdmCluster($clusterUuid: UUID!, $expireInDays: Long, $isForce: Boolean!) {
  result: removeCdmCluster(
    clusterUUID: $clusterUuid
    expireInDays: $expireInDays
    isForce: $isForce
  )
}`

// slaSourceClusters GraphQL query
var slaSourceClustersQuery = `query SdkGolangSlaSourceClusters(
  $after: String
  $first: Int
  $sortBy: SlaSourceClustersSortByField
  $sortOrder: SortOrder
  $filter: [SlaSourceClustersFilter!]
  $isArchivalSelected: Boolean
  $selectedReplication: SlaReplicationConfiguration
  $slaId: UUID
) {
  result: slaSourceClusters(
    after: $after
    first: $first
    sortBy: $sortBy
    sortOrder: $sortOrder
    filter: $filter
    isArchivalSelected: $isArchivalSelected
    selectedReplication: $selectedReplication
    slaId: $slaId
  ) {
    edges {
      cursor
      node {
        disableReasons
        hasProtectedObjects
        cluster {
          id
          name
          version
          clusterInfo {
            ... on LocalClusterInfo {
              isConnected
            }
            ... on CrossAccountClusterInfo {
              isConnected
            }
          }
        }
      }
    }
    pageInfo {
      startCursor
      endCursor
      hasPreviousPage
      hasNextPage
    }
    count
  }
}`

// updateClusterNtpServers GraphQL query
var updateClusterNtpServersQuery = `mutation SdkGolangUpdateClusterNtpServers($input: UpdateClusterNtpServersInput!) {
  result: updateClusterNtpServers(input: $input) {
    success
  }
}`

// updateClusterSettings GraphQL query
var updateClusterSettingsQuery = `mutation SdkGolangUpdateClusterSettings(
  $clusterID: UUID!
  $address: String!
  $name: String
  $timezone: ClusterTimezoneType!
) {
  result: updateClusterSettings(
    input: {
      clusterUuid: $clusterID
      id: "me"
      clusterUpdate: {
        geolocation: { address: $address }
        name: $name
        timezone: { timezone: $timezone }
      }
    }
  ) {
    geolocation {
      address
    }
    clusterUuid
    name
    timezone {
      timezone
    }
  }
}`

// updateCusterDnsAndSearchDomains GraphQL query
var updateCusterDnsAndSearchDomainsQuery = `mutation SdkGolangUpdateCusterDnsAndSearchDomains(
  $domains: [String!]!
  $id: String!
  $servers: [String!]!
) {
  result: updateDnsServersAndSearchDomains(
    input: { domains: $domains, id: $id, servers: $servers }
  ) {
    success
  }
}`

// verifySlaWithReplicationToCluster GraphQL query
var verifySlaWithReplicationToClusterQuery = `query SdkGolangVerifySlaWithReplicationToCluster($clusterUuid: UUID!, $includeArchived: Boolean!) {
  result: verifySlaWithReplicationToCluster(
    cdmClusterUUID: $clusterUuid
    includeArchived: $includeArchived
  ) {
    isActiveSla
  }
}`
